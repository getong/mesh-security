// only for valset_update but doesn't work for the autogenerated code
#![allow(clippy::too_many_arguments)]

use cosmwasm_schema::cw_serde;
use cosmwasm_std::{Coin, CustomMsg, CustomQuery, Response, StdError, Uint128, Validator};
use sylvia::ctx::ExecCtx;
use sylvia::interface;

/// The converter API is all calls that can be made from the virtual staking contract on this contract.
/// Updating the discount rate may be a custom API (such as SudoMsg), and all interactions with the
/// provider occur over IBC, so this is rather minimal
#[interface]
pub trait ConverterApi {
    type Error: From<StdError>;
    type ExecC: CustomMsg;
    type QueryC: CustomQuery;

    /// Rewards tokens (in native staking denom) are sent alongside the message, and should be distributed to all
    /// stakers who staked on this validator.
    #[sv::msg(exec)]
    fn distribute_reward(
        &self,
        ctx: ExecCtx<Self::QueryC>,
        validator: String,
    ) -> Result<Response<Self::ExecC>, Self::Error>;

    /// This is a batch for of distribute_reward, including the payment for multiple validators.
    /// This is more efficient than calling distribute_reward multiple times, but also more complex.
    ///
    /// info.funds sent along with the message should be the sum of all rewards for all validators,
    /// in the native staking denom.
    #[sv::msg(exec)]
    fn distribute_rewards(
        &self,
        ctx: ExecCtx<Self::QueryC>,
        payments: Vec<RewardInfo>,
    ) -> Result<Response<Self::ExecC>, Self::Error>;

    /// Valset updates.
    ///
    /// TODO: pubkeys need to be part of the Validator struct (requires CosmWasm support).
    #[sv::msg(exec)]
    fn valset_update(
        &self,
        ctx: ExecCtx<Self::QueryC>,
        additions: Vec<Validator>,
        removals: Vec<String>,
        updated: Vec<Validator>,
        jailed: Vec<String>,
        unjailed: Vec<String>,
        tombstoned: Vec<String>,
        slashed: Vec<ValidatorSlashInfo>,
    ) -> Result<Response<Self::ExecC>, Self::Error>;

    /// Send ibc packet, request the external staking contract to unstake
    #[sv::msg(exec)]
    fn internal_unstake(
        &self,
        ctx: ExecCtx<Self::QueryC>,
        delegator: String,
        validator: String,
        amount: Coin,
    ) -> Result<Response<Self::ExecC>, Self::Error>;
}

#[cw_serde]
#[derive(PartialOrd, Eq, Ord)]
pub struct RewardInfo {
    pub validator: String,
    pub reward: Uint128,
}

#[cw_serde]
pub struct ValidatorSlashInfo {
    /// The address of the validator.
    pub address: String,
    /// The height at which the misbehaviour occurred.
    pub infraction_height: u64,
    /// The time at which the misbehaviour occurred, in seconds.
    pub infraction_time: u64,
    /// The validator power when the misbehaviour occurred.
    pub power: u64,
    /// The slash amount over the amount delegated by virtual-staking for the validator.
    pub slash_amount: Coin,
    /// The (nominal) slash ratio for the validator.
    /// Useful in case we don't know if it's a double sign or downtime slash.
    pub slash_ratio: String,
}
